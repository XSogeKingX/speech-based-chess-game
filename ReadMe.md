# Voice-Controlled Chess Game in C++

This project is a classic chess game implemented in C++ with a unique twist: instead of traditional input, players use their voice to command the pieces. The game runs in a standard console environment and utilizes a sophisticated backend for speech recognition based on Hidden Markov Models (HMM).


---

## üìñ About The Project

The primary goal of this project was to build a functional chess game that could be controlled entirely through spoken commands. This involved two major components: a C++ chess engine to handle game logic and a complete speech recognition pipeline to interpret player input.

The speech recognition system is trained to recognize digits ("one", "two", ... "eight") which are used to specify the coordinates for piece movements (e.g., moving from row 2, column 5 to row 4, column 5).

---

## üöÄ Core Technologies & Concepts

The voice recognition engine is the heart of this project and is built using several classical signal processing and machine learning algorithms:

* **Programming Language:** **C++**
* **Audio I/O:** **Windows Multimedia API (`Winmm.lib`)** for recording and handling audio input from the microphone.
* **Feature Extraction:**
    * **Linear Predictive Coding (LPC):** Speech signals are analyzed to extract key features representing the vocal tract's characteristics.
    * **Levinson-Durbin Algorithm:** An efficient algorithm used to compute the LPC coefficients from the raw audio signal.
    * **Cepstral Coefficients:** LPC coefficients are converted into cepstral coefficients (Ceps), which are more robust for speech recognition.
* **Vector Quantization (VQ):**
    * **LBG Algorithm (Linde-Buzo-Gray):** This algorithm was used offline to create a "codebook" of representative feature vectors from a large set of training data.
    * During runtime, each frame's cepstral vector is replaced by the index of the closest matching vector in the codebook. This converts the continuous feature stream into a discrete sequence of observation symbols.
* **Pattern Recognition:**
    * **Hidden Markov Models (HMM):** The core of the recognition system. A separate HMM was trained for each digit (1-8).
    * **Forward Algorithm:** Given a sequence of observations from the VQ step, the Forward Algorithm is used to calculate the likelihood that the sequence was generated by each HMM. The digit corresponding to the model with the highest probability is chosen as the recognized command.

---

## üõ†Ô∏è Getting Started

To get a local copy up and running, follow these steps.

### Prerequisites

* A Windows operating system (due to the use of the Windows Multimedia API).
* A C++ compiler and environment, such as **Visual Studio** or **MinGW**.
* A microphone connected to your computer.

### Installation & Compilation

1.  **Clone the repository:**
    ```sh
    git clone <repo_url>
    ```
2.  **Ensure Model Files are Present:**
    This program relies on pre-trained models. Make sure the following files and directories are in the same location as your final executable:
    * A directory named `Trained_Model/` containing the HMM parameter files (`*_A.txt`, `*_B.txt`, `*_PI.txt`).
    * A file `cb.txt` (the codebook) inside an `Output_Training/` directory or at the location specified in the code.

3.  **Compile the Project:**
    If you are using Visual Studio, simply open the project and build it. The IDE should automatically link the required libraries.

    If you are compiling from the command line (e.g., with g++), you must link the **`Winmm.lib`** library.
    ```sh
    g++ ChessGame.cpp -o ChessGame.exe -lWinmm
    ```

---

## üéÆ How to Play

1.  **Run the executable** (`ChessGame.exe`) from your terminal.
2.  The current chess board will be displayed.
3.  The game will prompt **Player 1 (White)** to enter a move.
4.  **To specify a move, you need to provide source and destination coordinates.**
    * The game will first ask for the **Source Row**. Press any key to start recording, then clearly speak a digit from 1 to 8 into your microphone.
    * It will then ask for the **Source Column**. Do the same.
    * Repeat this process for the **Destination Row** and **Destination Column**.
5.  If the move is valid and the coordinates are recognized correctly, the piece will move, and the board will be updated.
6.  If the move is invalid, an error message will be shown, and you can try again.
7.  Play alternates between **White** and **Black**.

**Example:** To move a pawn from E2 to E4:
* When prompted for **Source Row**, say **"Two"**.
* When prompted for **Source Column**, say **"Five"** (since E is the 5th column).
* When prompted for **Destination Row**, say **"Four"**.
* When prompted for **Destination Column**, say **"Five"**.